# Pattern Matching Examples in Metorex

# ============================================
# BASIC LITERAL PATTERNS
# ============================================

# Match integers
match x
  case 0 -> "zero"
  case 1 -> "one"
  case 2 -> "two"
  case _ -> "other"
end

# Match strings
match command
  case "start" -> server.start()
  case "stop" -> server.stop()
  case "restart" -> server.restart()
  case "status" -> server.status()
  case _ -> error("Unknown command")
end

# Match booleans
match flag
  case true -> enable()
  case false -> disable()
end

# Match floats
match score
  case 0.0 -> "zero"
  case 1.0 -> "one"
  case _ -> "other"
end

# Match nil
match value
  case nil -> default_value()
  case v -> v
end

# ============================================
# VARIABLE BINDING PATTERNS
# ============================================

# Bind to variable
match x
  case n -> process(n)
end

# Multiple patterns with variable binding
match status
  case 200 -> "OK"
  case 404 -> "Not Found"
  case code -> "Error: #{code}"
end

# ============================================
# WILDCARD PATTERNS
# ============================================

# Wildcard as catch-all
match value
  case 1 -> "one"
  case 2 -> "two"
  case _ -> "many"
end

# Wildcard to ignore parts
match pair
  case [x, _] -> x  # Ignore second element
end

# ============================================
# ARRAY PATTERNS
# ============================================

# Match empty array
match arr
  case [] -> "empty"
  case _ -> "not empty"
end

# Match specific array
match arr
  case [1, 2, 3] -> "found [1, 2, 3]"
  case _ -> "something else"
end

# Match array with variables
match arr
  case [first, second] -> first + second
  case _ -> 0
end

# Match array with wildcards
match arr
  case [x, _, z] -> x + z  # Ignore middle element
  case _ -> 0
end

# Match nested arrays
match matrix
  case [[a, b], [c, d]] -> a + b + c + d
  case _ -> 0
end

# Match arrays of different lengths
match arr
  case [] -> "empty"
  case [x] -> "single: #{x}"
  case [x, y] -> "pair: #{x}, #{y}"
  case _ -> "many"
end

# ============================================
# REST PATTERNS (Array Destructuring)
# ============================================

# Rest at end
match arr
  case [first, ...rest] -> process_first(first) + process_rest(rest)
  case _ -> nil
end

# Multiple elements before rest
match arr
  case [a, b, ...rest] -> [a, b, rest]
  case _ -> nil
end

# Rest in middle positions
match arr
  case [first, ...middle, last] -> [first, middle, last]
  case _ -> nil
end

# Rest with empty remainder
match [1]
  case [first, ...rest] -> rest  # rest is []
end

# Rest in nested patterns
match data
  case [[first, ...rest], other] -> process(first, rest, other)
  case _ -> nil
end

# ============================================
# OBJECT/DICTIONARY PATTERNS
# ============================================

# Match empty object
match obj
  case {} -> "empty object"
  case _ -> "not empty"
end

# Match specific keys
match point
  case {x: 0, y: 0} -> "origin"
  case {x: x, y: 0} -> "on x-axis at #{x}"
  case {x: 0, y: y} -> "on y-axis at #{y}"
  case _ -> "elsewhere"
end

# Destructure object
match user
  case {name: n, age: a} -> "#{n} is #{a} years old"
  case _ -> "invalid user"
end

# Partial object matching
match config
  case {debug: true} -> enable_debug()
  case {debug: false} -> disable_debug()
  case _ -> use_default_debug()
end

# Nested object patterns
match data
  case {user: {name: name, age: age}, status: status} ->
    "User #{name} (#{age}) is #{status}"
  case _ ->
    "invalid data"
end

# Object with array values
match data
  case {items: [first, ...rest], count: c} ->
    process_items(first, rest, c)
  case _ ->
    nil
end

# Complex nested structures
match response
  case {
    status: 200,
    data: {
      user: {name: name, email: email},
      posts: [first_post, ...other_posts]
    }
  } ->
    display_user(name, email, first_post, other_posts)
  case {status: code} ->
    handle_error(code)
  case _ ->
    handle_invalid_response()
end

# ============================================
# TYPE PATTERNS
# ============================================

# Match by type
match value
  case String -> value.upcase()
  case Integer -> value * 2
  case Float -> value.round()
  case Array -> value.length()
  case Hash -> value.keys
  case _ -> nil
end

# Type with binding
match obj
  case String => s -> s.trim()
  case Integer => n -> n + 1
  case _ -> obj
end

# ============================================
# GUARDS (CONDITIONAL PATTERNS)
# ============================================

# Simple guard
match x
  case n if n > 0 -> "positive"
  case n if n < 0 -> "negative"
  case _ -> "zero"
end

# Multiple guards
match x
  case n if n > 100 -> "large"
  case n if n > 10 -> "medium"
  case n if n > 0 -> "small"
  case _ -> "non-positive"
end

# Guard with complex condition
match user
  case u if u.age >= 18 && u.verified -> grant_access(u)
  case u if u.age >= 18 -> require_verification(u)
  case u -> deny_access(u)
end

# Guard with method calls
match item
  case i if i.valid?() -> process(i)
  case i if i.repairable?() -> repair_and_process(i)
  case _ -> discard()
end

# Array pattern with guard
match arr
  case [first, ...rest] if rest.length() > 0 ->
    process_multiple(first, rest)
  case [single] ->
    process_single(single)
  case _ ->
    process_empty()
end

# Object pattern with guard
match config
  case {debug: d, level: l} if l > 5 ->
    enable_verbose_debug()
  case {debug: true} ->
    enable_debug()
  case _ ->
    disable_debug()
end

# ============================================
# COMBINED PATTERNS
# ============================================

# Literals, arrays, and objects
match data
  case nil -> "no data"
  case [] -> "empty array"
  case {} -> "empty object"
  case [x] -> "single item: #{x}"
  case {key: value} -> "single pair: #{key} = #{value}"
  case _ -> "complex data"
end

# Nested patterns with guards
match request
  case {
    method: "GET",
    path: p,
    params: {id: id}
  } if valid_id?(id) ->
    handle_get(p, id)

  case {
    method: "POST",
    path: p,
    body: [item, ...items]
  } if items.length() > 0 ->
    handle_batch_post(p, item, items)

  case {method: m} ->
    handle_unsupported_method(m)

  case _ ->
    handle_invalid_request()
end

# ============================================
# PRACTICAL EXAMPLES
# ============================================

# Parse HTTP response
match response
  case {status: 200, body: data} ->
    success(data)

  case {status: 201, body: data, headers: h} ->
    created(data, h)

  case {status: code} if code >= 400 && code < 500 ->
    client_error(code)

  case {status: code} if code >= 500 ->
    server_error(code)

  case _ ->
    unknown_error()
end

# Parse JSON data
match json
  case {type: "user", data: {name: n, email: e}} ->
    create_user(n, e)

  case {type: "post", data: {title: t, content: c, author: a}} ->
    create_post(t, c, a)

  case {type: "comment", data: d} ->
    create_comment(d)

  case {type: t} ->
    unknown_type(t)

  case _ ->
    invalid_json()
end

# Parse command line arguments
match args
  case ["help"] ->
    show_help()

  case ["version"] ->
    show_version()

  case ["run", file] ->
    run_file(file)

  case ["test", ...test_files] ->
    run_tests(test_files)

  case ["build", "--release"] ->
    build_release()

  case ["build"] ->
    build_debug()

  case [command, ...args] ->
    unknown_command(command, args)

  case [] ->
    show_usage()
end

# Parse coordinates
match position
  case {x: 0, y: 0, z: 0} ->
    "origin"

  case {x: x, y: 0, z: 0} ->
    "on x-axis at #{x}"

  case {x: 0, y: y, z: 0} ->
    "on y-axis at #{y}"

  case {x: 0, y: 0, z: z} ->
    "on z-axis at #{z}"

  case {x: x, y: y, z: 0} ->
    "on xy-plane at (#{x}, #{y})"

  case {x: x, y: y, z: z} ->
    "at (#{x}, #{y}, #{z})"
end

# Parse tree structure
match tree
  case {type: "leaf", value: v} ->
    process_leaf(v)

  case {type: "node", left: l, right: r} ->
    process_node(l, r)

  case {type: "node", children: []} ->
    empty_node()

  case {type: "node", children: [child]} ->
    single_child_node(child)

  case {type: "node", children: [first, ...rest]} ->
    multi_child_node(first, rest)

  case _ ->
    invalid_tree()
end

# ============================================
# PATTERN MATCHING IN FUNCTIONS
# ============================================

# Function with pattern matching
def handle_result(result)
  match result
    case {success: true, data: d} -> process_success(d)
    case {success: false, error: e} -> handle_error(e)
    case _ -> handle_unknown()
  end
end

# Function with direct pattern match in parameters
def process_point(point)
  match point
    case {x: x, y: y} -> calculate_distance(x, y)
    case [x, y] -> calculate_distance(x, y)
    case _ -> 0
  end
end

# Multiple pattern matches in sequence
def categorize(value)
  type_category = match value
    case String -> "text"
    case Integer -> "number"
    case _ -> "other"
  end

  size_category = match value
    case v if v.length() > 100 -> "large"
    case v if v.length() > 10 -> "medium"
    case _ -> "small"
  end

  [type_category, size_category]
end

# ============================================
# PATTERN MATCHING WITH COLLECTIONS
# ============================================

# Filter with pattern matching
items.filter do |item|
  match item
    case {valid: true} -> true
    case _ -> false
  end
end

# Map with pattern matching
users.map do |user|
  match user
    case {name: n, age: a} if a >= 18 -> {name: n, status: "adult"}
    case {name: n, age: a} -> {name: n, status: "minor"}
    case _ -> {status: "unknown"}
  end
end

# Reduce with pattern matching
events.reduce(initial_state) do |state, event|
  match event
    case {type: "add", value: v} -> state + v
    case {type: "subtract", value: v} -> state - v
    case {type: "multiply", value: v} -> state * v
    case {type: "divide", value: v} -> state / v
    case _ -> state
  end
end

# ============================================
# PATTERN MATCHING STATE MACHINES
# ============================================

def process_state_machine(state, event)
  match [state, event]
    case ["idle", {type: "start"}] ->
      transition_to("running")

    case ["running", {type: "pause"}] ->
      transition_to("paused")

    case ["paused", {type: "resume"}] ->
      transition_to("running")

    case ["running", {type: "stop"}] ->
      transition_to("stopped")

    case [s, {type: "reset"}] ->
      transition_to("idle")

    case [s, e] ->
      error("Invalid transition: #{s} + #{e.type}")
  end
end

# ============================================
# PATTERN MATCHING FOR VALIDATION
# ============================================

def validate_user(user)
  match user
    case nil ->
      error("User is nil")

    case {name: nil} ->
      error("Name is required")

    case {name: ""} ->
      error("Name cannot be empty")

    case {name: n, email: nil} ->
      error("Email is required for #{n}")

    case {name: n, email: e} if !valid_email?(e) ->
      error("Invalid email for #{n}: #{e}")

    case {name: n, email: e, age: a} if a < 0 ->
      error("Invalid age for #{n}: #{a}")

    case {name: n, email: e, age: a} if a >= 0 && a < 18 ->
      warning("User #{n} is a minor")
      user

    case {name: n, email: e, age: a} ->
      user

    case _ ->
      error("Invalid user object")
  end
end

# ============================================
# PATTERN MATCHING FOR PARSING
# ============================================

def parse_expression(tokens)
  match tokens
    case ["(", ...inner, ")"] ->
      {type: "grouped", inner: inner}

    case [operator, left, right] if is_binary_op?(operator) ->
      {type: "binary", op: operator, left: left, right: right}

    case [operator, operand] if is_unary_op?(operator) ->
      {type: "unary", op: operator, operand: operand}

    case [literal] if is_literal?(literal) ->
      {type: "literal", value: literal}

    case [identifier] ->
      {type: "identifier", name: identifier}

    case _ ->
      error("Invalid expression")
  end
end

# ============================================
# EXHAUSTIVENESS AND COMPLETENESS
# ============================================

# Exhaustive pattern matching ensures all cases are covered
def handle_option(opt)
  match opt
    case {some: value} -> process(value)
    case nil -> default_value()
  end
end

# Using wildcard for completeness
def safe_divide(a, b)
  match [a, b]
    case [_, 0] -> error("Division by zero")
    case [x, y] -> x / y
  end
end

# Ordering matters - more specific patterns first
def classify_number(n)
  match n
    case 0 -> "zero"
    case 1 -> "one"
    case n if n > 0 && n < 10 -> "small positive"
    case n if n > 0 -> "large positive"
    case n if n < 0 && n > -10 -> "small negative"
    case n if n < 0 -> "large negative"
  end
end
