# Class Definition Examples
# This file demonstrates various class definition patterns

# Basic class definition with no methods
class Empty
end

# Simple class with a method
class Greeter
  def greet
    "Hello, World!"
  end
end

# Class with constructor (initialize method)
class Person
  def initialize(name, age)
    @name = name
    @age = age
  end

  def introduce
    "My name is " + @name + " and I am " + @age + " years old"
  end
end

# Class with default parameter values in constructor
class Product
  def initialize(name, price=0, quantity=1)
    @name = name
    @price = price
    @quantity = quantity
  end

  def total_value
    @price * @quantity
  end
end

# Class with multiple instance variables
class Rectangle
  def initialize(width, height)
    @width = width
    @height = height
  end

  def area
    @width * @height
  end

  def perimeter
    2 * (@width + @height)
  end

  def set_width(width)
    @width = width
  end

  def set_height(height)
    @height = height
  end

  def get_width
    @width
  end

  def get_height
    @height
  end
end

# Class with class variables
class Counter
  def initialize
    @@count = 0
  end

  def increment
    @@count = @@count + 1
  end

  def get_count
    @@count
  end
end

# Inheritance - simple case
class Animal
  def initialize(name)
    @name = name
  end

  def speak
    "Some sound"
  end

  def introduce
    @name + " says " + speak
  end
end

# Class inheriting from Animal
class Dog < Animal
  def speak
    "Woof!"
  end

  def fetch
    "Fetching the ball"
  end
end

# Another class inheriting from Animal
class Cat < Animal
  def speak
    "Meow!"
  end

  def purr
    "Purring..."
  end
end

# Multi-level inheritance
class Bird < Animal
  def speak
    "Chirp!"
  end

  def fly
    "Flying high"
  end
end

class Penguin < Bird
  def fly
    "Cannot fly, but can swim!"
  end

  def swim
    "Swimming in the ocean"
  end
end

# Class with methods that have different parameter types
class Calculator
  def initialize(initial_value=0)
    @value = initial_value
  end

  def add(x, y=0)
    x + y
  end

  def sum_all(*numbers)
    total = 0
    for num in numbers
      total = total + num
    end
    total
  end

  def configure(**options)
    if options["precision"]
      @precision = options["precision"]
    end
  end
end

# Class with control flow in methods
class NumberChecker
  def initialize(number)
    @number = number
  end

  def classify
    if @number < 0
      return "negative"
    end
    if @number == 0
      return "zero"
    end
    "positive"
  end

  def is_even
    if @number % 2 == 0
      true
    else
      false
    end
  end

  def factorial
    if @number < 0
      return nil
    end
    if @number == 0
      return 1
    end

    result = 1
    i = 1
    while i <= @number
      result = result * i
      i = i + 1
    end
    result
  end
end

# Class with pattern matching
class Matcher
  def initialize(value)
    @value = value
  end

  def describe
    match @value
      0 => "zero"
      1 => "one"
      _ => "other number"
    end
  end
end

# Class with exception handling
class SafeDivider
  def initialize(numerator)
    @numerator = numerator
  end

  def divide(denominator)
    begin
      return @numerator / denominator
    rescue ZeroDivisionError => e
      puts "Cannot divide by zero"
      return nil
    end
  end
end

# Class with nested method definitions
class OuterClass
  def outer_method(x)
    def inner_method(y)
      x + y
    end
    inner_method(10)
  end
end

# Class with lambda/block usage
class Processor
  def initialize(data)
    @data = data
  end

  def transform(operation)
    operation.call(@data)
  end

  def create_multiplier(factor)
    lambda do |x|
      x * factor
    end
  end
end

# Class with array and dictionary instance variables
class DataStore
  def initialize
    @items = []
    @metadata = {}
  end

  def add_item(item)
    @items.push(item)
  end

  def set_metadata(key, value)
    @metadata[key] = value
  end

  def get_items
    @items
  end

  def get_metadata
    @metadata
  end
end

# Class with complex initialization
class ComplexInit
  def initialize(required_param, optional_param="default", *args, **kwargs)
    @required = required_param
    @optional = optional_param
    @args = args
    @kwargs = kwargs
  end

  def get_all_data
    {
      "required" => @required,
      "optional" => @optional,
      "args" => @args,
      "kwargs" => @kwargs
    }
  end
end

# Class with method chaining
class Chainable
  def initialize(value)
    @value = value
  end

  def add(x)
    @value = @value + x
    self
  end

  def multiply(x)
    @value = @value * x
    self
  end

  def get_value
    @value
  end
end

# Class demonstrating various access patterns
class AccessPatterns
  def initialize
    @public_data = "public"
    @_private_data = "private"
  end

  def get_public
    @public_data
  end

  def _get_private
    @_private_data
  end

  def update_both(public_val, private_val)
    @public_data = public_val
    @_private_data = private_val
  end
end

# Empty class inheriting from another class
class Base
  def base_method
    "base"
  end
end

class Derived < Base
end
