# Exception Handling Examples in Metorex

# ============================================
# BASIC EXCEPTION HANDLING
# ============================================

# Simple begin/rescue/end
begin
  risky_operation()
rescue
  handle_error()
end

# Rescue with exception type
begin
  file.read()
rescue IOError
  print("Could not read file")
end

# Rescue with variable binding
begin
  parse_data(input)
rescue ParseError => e
  print("Parse error: #{e.message}")
end

# Multiple rescue clauses
begin
  network_call()
rescue NetworkError => e
  retry_with_backoff()
rescue TimeoutError => e
  log_timeout(e)
rescue => e
  log_generic_error(e)
end

# ============================================
# RESCUE WITH SPECIFIC EXCEPTION TYPES
# ============================================

# Single exception type
begin
  db.query(sql)
rescue DatabaseError => e
  handle_db_error(e)
end

# Multiple exception types in one rescue
begin
  perform_request()
rescue NetworkError, TimeoutError, ConnectionError => e
  handle_network_problem(e)
end

# Different handlers for different exceptions
begin
  process_file(filename)
rescue FileNotFoundError => e
  create_file(filename)
rescue PermissionError => e
  request_permission(filename)
rescue IOError => e
  log_io_error(e)
end

# ============================================
# ELSE AND ENSURE CLAUSES
# ============================================

# Else clause (runs if no exception)
begin
  result = compute()
rescue Error => e
  handle_error(e)
else
  log_success(result)
end

# Ensure clause (always runs)
begin
  file = open("data.txt")
  process(file)
rescue IOError => e
  log_error(e)
ensure
  file.close() if file
end

# All clauses together
begin
  resource = acquire_resource()
  work_with(resource)
rescue ResourceError => e
  handle_resource_error(e)
else
  log_success()
ensure
  release_resource(resource) if resource
end

# ============================================
# RAISE STATEMENTS
# ============================================

# Raise with string
raise "Something went wrong"

# Raise with exception object
raise StandardError.new("Error message")

# Raise specific exception type
raise ArgumentError.new("Invalid argument")

# Raise with formatted message
raise "Value #{value} is out of range"

# Conditional raise
if !valid
  raise ValidationError.new("Validation failed")
end

# Raise in method
def validate(value)
  if value < 0
    raise ArgumentError.new("Value must be positive")
  end
  value
end

# ============================================
# RE-RAISING EXCEPTIONS
# ============================================

# Bare raise (re-raises current exception)
begin
  dangerous_operation()
rescue StandardError => e
  log_error(e)
  raise  # Re-raise the exception
end

# Log and re-raise
begin
  process()
rescue => e
  logger.error("Error occurred: #{e.message}")
  logger.debug("Stack trace: #{e.backtrace}")
  raise
end

# Conditional re-raise
begin
  attempt_operation()
rescue TransientError => e
  if retries < max_retries
    retries += 1
    retry
  else
    raise  # Re-raise if max retries exceeded
  end
end

# ============================================
# NESTED EXCEPTION HANDLING
# ============================================

# Nested begin blocks
begin
  outer_operation()

  begin
    inner_operation()
  rescue InnerError => e
    handle_inner_error(e)
  end

rescue OuterError => e
  handle_outer_error(e)
end

# Exception handling in nested calls
begin
  begin
    begin
      deeply_nested_call()
    rescue LevelThreeError => e
      log("Level 3 error")
      raise
    end
  rescue LevelTwoError => e
    log("Level 2 error")
    raise
  end
rescue LevelOneError => e
  log("Level 1 error")
end

# ============================================
# EXCEPTION HANDLING IN METHODS
# ============================================

# Method with exception handling
def safe_divide(a, b)
  begin
    a / b
  rescue ZeroDivisionError
    return 0
  end
end

# Method that handles and returns
def read_config(filename)
  begin
    file = open(filename)
    parse(file.read())
  rescue FileNotFoundError
    return default_config()
  rescue ParseError => e
    log_error("Failed to parse config: #{e}")
    return default_config()
  ensure
    file.close() if file
  end
end

# Method with ensure for cleanup
def process_with_lock(resource)
  begin
    lock.acquire()
    process(resource)
  ensure
    lock.release()
  end
end

# ============================================
# EXCEPTION HANDLING PATTERNS
# ============================================

# Retry pattern
attempts = 0
max_attempts = 3

begin
  perform_operation()
rescue TransientError => e
  attempts += 1
  if attempts < max_attempts
    sleep(1)
    retry
  else
    raise
  end
end

# Fallback pattern
def get_data
  begin
    fetch_from_primary()
  rescue ConnectionError
    begin
      fetch_from_secondary()
    rescue ConnectionError
      fetch_from_cache()
    end
  end
end

# Resource cleanup pattern
def with_resource(name)
  resource = nil
  begin
    resource = acquire(name)
    yield(resource)
  rescue ResourceError => e
    log_error(e)
    nil
  ensure
    release(resource) if resource
  end
end

# Ignore exceptions pattern
begin
  optional_operation()
rescue
  # Silently ignore
end

# Convert exceptions pattern
begin
  external_call()
rescue ExternalError => e
  raise InternalError.new("Internal error: #{e.message}")
end

# ============================================
# EXCEPTION HANDLING WITH CONTROL FLOW
# ============================================

# Exception in loop
items.each do |item|
  begin
    process(item)
  rescue ProcessError => e
    log_error("Failed to process #{item}: #{e}")
    next
  end
end

# Exception with break
loop do
  begin
    work = queue.pop()
    process(work)
  rescue FatalError => e
    log_fatal(e)
    break
  rescue RetriableError => e
    log_warning(e)
    # Continue loop
  end
end

# Exception in conditional
if condition
  begin
    risky_true_branch()
  rescue Error => e
    handle_true_error(e)
  end
else
  begin
    risky_false_branch()
  rescue Error => e
    handle_false_error(e)
  end
end

# ============================================
# ADVANCED PATTERNS
# ============================================

# Multiple rescue with different return values
def safe_operation
  begin
    perform_operation()
  rescue NetworkError
    return :network_error
  rescue TimeoutError
    return :timeout
  rescue => e
    return :unknown_error
  else
    return :success
  end
end

# Exception chain
begin
  step1()
  step2()
  step3()
rescue Step1Error => e
  log("Failed at step 1")
  cleanup_step1()
rescue Step2Error => e
  log("Failed at step 2")
  cleanup_step2()
  cleanup_step1()
rescue Step3Error => e
  log("Failed at step 3")
  cleanup_step3()
  cleanup_step2()
  cleanup_step1()
end

# Nested rescue with different scopes
begin
  outer_resource = acquire_outer()

  begin
    inner_resource = acquire_inner()
    work(outer_resource, inner_resource)
  rescue InnerError => e
    handle_inner(e)
  ensure
    release_inner(inner_resource) if inner_resource
  end

rescue OuterError => e
  handle_outer(e)
ensure
  release_outer(outer_resource) if outer_resource
end

# Conditional exception handling
begin
  operation()
rescue Error => e
  if e.retriable?
    retry_operation()
  elsif e.ignorable?
    # Ignore
  else
    raise
  end
end

# ============================================
# EXCEPTION HANDLING IN CLASS METHODS
# ============================================

class FileProcessor
  def initialize(filename)
    @filename = filename
    @file = nil
  end

  def process
    begin
      @file = open(@filename)
      data = @file.read()
      transform(data)
    rescue FileNotFoundError => e
      raise ProcessError.new("File not found: #{@filename}")
    rescue IOError => e
      raise ProcessError.new("IO error: #{e.message}")
    ensure
      close_file()
    end
  end

  def close_file
    begin
      @file.close() if @file
    rescue
      # Ignore errors during cleanup
    end
  end
end

# ============================================
# EXCEPTION WITH STATE MANAGEMENT
# ============================================

# Save and restore state
def transactional_operation
  saved_state = save_state()

  begin
    modify_state()
    perform_operation()
  rescue Error => e
    restore_state(saved_state)
    raise
  end
end

# Rollback pattern
def atomic_updates(items)
  completed = []

  begin
    items.each do |item|
      update(item)
      completed.push(item)
    end
  rescue UpdateError => e
    # Rollback completed updates
    completed.reverse_each do |item|
      rollback(item)
    end
    raise
  end
end

# ============================================
# CUSTOM EXCEPTION HANDLING
# ============================================

# Rescue with message pattern matching
begin
  operation()
rescue Error => e
  if e.message.include?("timeout")
    handle_timeout()
  elsif e.message.include?("network")
    handle_network()
  else
    handle_generic(e)
  end
end

# Rescue with exception hierarchy
begin
  operation()
rescue SpecificError => e
  handle_specific(e)
rescue BaseError => e
  handle_base(e)
rescue => e
  handle_any(e)
end

# ============================================
# EXCEPTION HANDLING WITH CALLBACKS
# ============================================

# Before/after pattern with exceptions
def with_callbacks
  before_operation()

  begin
    result = perform_operation()
    after_operation_success(result)
    result
  rescue Error => e
    after_operation_failure(e)
    raise
  ensure
    after_operation_always()
  end
end

# ============================================
# REAL-WORLD EXAMPLES
# ============================================

# Database connection with retry
def connect_to_database
  retries = 0

  begin
    db = Database.connect(config)
    return db
  rescue ConnectionError => e
    retries += 1
    if retries < 3
      log("Connection failed, retrying (#{retries}/3)")
      sleep(retries * 2)
      retry
    else
      log_error("Failed to connect after 3 attempts")
      raise DatabaseUnavailable.new("Could not connect to database")
    end
  end
end

# File upload with cleanup
def upload_file(local_path, remote_path)
  temp_file = nil

  begin
    # Prepare file
    temp_file = compress(local_path)

    # Upload
    client = S3Client.new()
    client.upload(temp_file, remote_path)

    log("Successfully uploaded #{local_path} to #{remote_path}")
    return true

  rescue CompressionError => e
    log_error("Failed to compress file: #{e.message}")
    return false

  rescue NetworkError => e
    log_error("Upload failed due to network error: #{e.message}")
    return false

  rescue => e
    log_error("Unexpected error during upload: #{e.message}")
    raise

  ensure
    # Always cleanup temp file
    if temp_file
      begin
        delete(temp_file)
      rescue
        log_warning("Could not delete temp file: #{temp_file}")
      end
    end
  end
end

# API request with timeout and retry
def api_request(endpoint, params)
  attempts = 0
  max_attempts = 3

  begin
    attempts += 1

    response = HTTP.get(endpoint, params, timeout: 30)

    if response.success?
      return response.body
    else
      raise APIError.new("HTTP #{response.status}: #{response.message}")
    end

  rescue TimeoutError => e
    if attempts < max_attempts
      log("Request timeout, retrying (#{attempts}/#{max_attempts})")
      sleep(2 ** attempts)
      retry
    else
      raise APITimeout.new("Request timed out after #{max_attempts} attempts")
    end

  rescue NetworkError => e
    if attempts < max_attempts && e.retriable?
      log("Network error, retrying (#{attempts}/#{max_attempts})")
      retry
    else
      raise
    end

  rescue => e
    log_error("Unexpected API error: #{e.message}")
    raise
  end
end

# Transaction pattern
def perform_transaction(operations)
  transaction = db.begin_transaction()

  begin
    operations.each do |op|
      op.execute(transaction)
    end

    transaction.commit()
    log("Transaction committed successfully")
    return true

  rescue ValidationError => e
    transaction.rollback()
    log_error("Transaction rolled back: validation failed - #{e.message}")
    return false

  rescue DatabaseError => e
    transaction.rollback()
    log_error("Transaction rolled back: database error - #{e.message}")
    raise

  rescue => e
    transaction.rollback()
    log_error("Transaction rolled back: unexpected error - #{e.message}")
    raise

  ensure
    transaction.close() if transaction
  end
end
