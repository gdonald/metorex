# Example method calls and property access in Metorex

# Simple method calls with no arguments
obj.method()
object.to_string()
item.process()

# Property access (method call without parentheses)
person.name
user.email
product.price

# Method calls with single argument
arr.push(1)
string.concat("hello")
list.append(item)

# Method calls with multiple arguments
calculator.add(1, 2)
obj.method(x, y, z)
processor.compute(a, b, c, d)

# Method chaining
obj.method1().method2()
string.trim().upcase()
arr.filter(predicate).map(transform)

# Three-level method chaining
obj.foo().bar().baz()
data.clean().transform().validate()

# Four-level method chaining
result.step1().step2().step3().step4()

# Property access chaining
obj.property.nested_property
user.profile.settings.theme
document.metadata.author.name

# Mixed chaining (properties and method calls)
obj.property.method()
user.profile.get_name()
data.results.first()

# Method calls with chaining on results
obj.get_list().first()
user.get_friends().count()
api.fetch_data().parse()

# Method calls on instance variables
@name.upcase()
@items.length()
@value.to_string()

# Method calls on class variables
@@count.increment()
@@config.get("key")
@@registry.lookup(id)

# Method calls on literals
"hello".upcase()
"world".length()
42.to_string()
3.14.round()
[1, 2, 3].length()
{x: 1, y: 2}.keys()

# Self references
self
self.method()
self.property
self.calculate(x, y)

# Self in method chaining
self.foo().bar()
self.value.upcase()
self.items.first()

# Method calls with complex arguments
obj.method(x + y)
calc.compute(a * b, c / d)
processor.run(arr[0], hash["key"])

# Method calls with nested method calls as arguments
obj.outer(inner.method())
calculator.add(x.value(), y.value())
processor.compute(a.get(), b.get(), c.get())

# Method calls on array elements
arr[0].method()
items[i].process()
matrix[x][y].value()

# Method calls on dictionary values
hash["key"].method()
config["setting"].upcase()
data[id].to_json()

# Method calls on expressions
(x + y).to_string()
(a * b).abs()
(obj1 || obj2).method()

# Method calls in binary operations
obj.value() + 10
x.get() * y.get()
a.compare(b) == 0

# Method calls in unary operations
-obj.value()
+x.get()

# Method calls as function arguments
foo(obj.method())
calculate(x.value(), y.value())
process(item.transform(), filter.apply())

# Chained method calls with arguments
obj.method1(x).method2(y).method3(z)
data.filter(pred).map(fn).reduce(acc)

# Method calls on method call results
obj.get_processor().process()
user.get_profile().get_name()
api.fetch().parse().validate()

# Property access on method call results
obj.get_data().results
user.fetch_profile().name
api.get_response().status

# Mixed expressions with method calls
[obj1.method(), obj2.method(), obj3.method()]
{x: a.get(), y: b.get(), z: c.get()}
(obj.value() + 10) * 2

# Method calls in conditionals
if obj.is_valid()
  obj.process()
end

if user.has_permission("admin")
  admin.grant_access()
end

# Method calls in loops
while iterator.has_next()
  iterator.next()
end

# Method calls in assignments
x = obj.method()
y = user.get_value()
z = calculator.compute(a, b)

# Compound assignments with method calls
x += obj.delta()
y *= factor.get()
z -= adjustment.calculate()

# Method calls on self in instance methods
@value = self.calculate()
@result = self.process().format()
@data = self.fetch().clean().validate()

# Complex nested structures
obj.get_list()[0].process().result
user.profile.settings["theme"].name.upcase()
api.fetch().data.items.first().id

# Lambda with method calls
arr.map(x -> x.value())
items.filter(item -> item.is_valid())
data.reduce((acc, x) -> acc.add(x.value()))

# Method calls returning callables
obj.get_function()()
factory.create_processor()(data)
builder.get_handler()(event)

# Fluent interface pattern
builder
  .with_name("Alice")
  .with_age(30)
  .with_email("alice@example.com")
  .build()

# Builder pattern with self chaining
self
  .set_x(10)
  .set_y(20)
  .set_z(30)
  .finalize()

# Method calls with all argument types
obj.method(
  42,                    # integer
  3.14,                  # float
  "string",              # string
  true,                  # boolean
  nil,                   # nil
  variable,              # identifier
  @instance,             # instance variable
  @@class_var,           # class variable
  [1, 2, 3],            # array
  {x: 1, y: 2},         # dictionary
  other.method(),        # method call
  x + y                  # expression
)

# Edge cases

# Empty method call chains (just property access)
obj.prop1.prop2.prop3.prop4.prop5

# Very long method chain
data
  .step1()
  .step2()
  .step3()
  .step4()
  .step5()
  .step6()
  .step7()
  .step8()
  .step9()
  .step10()

# Nested self references
self.get_self().method()
self.clone().process()

# Method calls in all positions
x = obj.a() + obj.b() * obj.c() / obj.d()

# Property access with reserved-looking names
obj.def_value
obj.class_name
obj.if_condition
obj.while_counter
